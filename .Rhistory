##
## Sensitivity analysis below
##
## clean up
rm(list=ls())
# instal r developer toolbox first (Rtools from Cran R)
## pomp test run lbv
getwd()
setwd("~/GitHub/LBV") # revise as necessary
library(pomp)
#Compiling C code and loading the dll
# dyn.unload("lbvseirNoSeasFreqTwoParsMeasure.dll")
#dyn.unload("lbvseirNoSeasFreqTwoParsImMeasure.dll")
system("R CMD SHLIB lbvseirNoSeasFreqTwoParsMeasureBinom.c")
dyn.load("lbvseirNoSeasFreqTwoParsMeasureBinom.dll")
# dyn.unload("lbvseirNoSeasFreqTwoParsMeasureBinom.dll")
pomp(
data = data.frame(
time=seq(from=0,to=365*25,by=1),  # time for simulations to run
X = NA # dummy variables
),
times="time",
t0=0,
## native routine for the process simulator:
rprocess=euler.sim(
step.fun="sir_euler_simulator",
delta.t=1,
#PACKAGE="pomp"  ## may be include if does not work - this is where to look for the c file
## name of the shared-object library containing the PACKAGE="pomp",
),
## the order of the state variables assumed in the native routines:
statenames=c("SUSJ","MDAJ", "SUSJM","EIJ","ERJ","INFJ", "RECJ", "SUSA", "EIA","ERA","INFA", "RECA","SPA","SPJ"),
## the order of the parameters assumed in the native routines:
paramnames=c("BETA",
"RHO",
# "ETA",
"SUSJ.0","MDAJ.0", "SUSJM.0","EIJ.0","ERJ.0","INFJ.0", "RECJ.0", "SUSA.0", "EIA.0","ERA.0","INFA.0", "RECA.0","SPA.0","SPJ.0"),
initializer=function(params,t0,statenames,...){
x0<-params[paste(statenames,".0",sep="")]
names(x0)<-statenames
return(x0)
}
) -> sir
params <- c(
BETA=5,
RHO=0.126,
#  ETA=0.1,
SUSJ.0=4000,MDAJ.0=4000, SUSJM.0=1000,EIJ.0=1000,ERJ.0=1000,INFJ.0=1000,
RECJ.0=10000,SUSA.0=50000, EIA.0=100,
ERA.0=1000,INFA.0=5000, RECA.0=50000,
SPA.0=0.4994506,SPJ.0=0.5882353)
#
sim <- simulate(sir,params=c(params),seed=3493885L,nsim=1,states=T,obs=F,as.data.frame=T) #
class(sir) # pomp object
class(sim) # data frame - change states, obs and data.frame if want pomp obj
#
plot(sim$time,sim$SUSJ,type="l")
points(sim$time,sim$RECJ,col="green",type="l")
points(sim$time,sim$MDA,col="brown",type="l")
points(sim$time,sim$INFJ,col="red",type="l")
#
plot(sim$time,sim$SUSA,type="l")
points(sim$time,sim$RECA,col="green",type="l")
points(sim$time,sim$INFA,col="red",type="l")
#
plot(sim$time,sim$SPA,type="l",col="green",ylim=c(0,1))
points(sim$time,sim$SPJ,type="l",col="red")
points(sim$time,sim$SUSA,col="green",type="l")
plot(sim$time,sim$RECA,type="l")
plot(sim$time,sim$SUSA,col="green",type="l")
points(sim$time,sim$RECA,type="l")
points(sim$time,sim$INFA,col="red",type="l")
plot(sim$time,sim$RECA,col="green",type="l")
points(sim$time,sim$SUSA,type="l")
points(sim$time,sim$INFA,col="red",type="l")
plot(sim$time,sim$RECA,col="green",type="l",ylim=c(0,max(sim)))
plot(sim$time,sim$RECA,col="green",type="l",ylim=c(0,max(sim$RECA)))
points(sim$time,sim$SUSA,type="l")
points(sim$time,sim$INFA,col="red",type="l")
#
plot(sim$time,sim$SPA,type="l",col="green",ylim=c(0,1))
points(sim$time,sim$SPJ,type="l",col="red")
params <- c(
BETA=5,
RHO=0.126, # * 5 is to ensure infection persists
#ETA=0.01,# check data
SUSJ.0=4000,MDAJ.0=4000, SUSJM.0=1000,EIJ.0=1000,ERJ.0=1000,INFJ.0=1000,
RECJ.0=10000,SUSA.0=50000, EIA.0=100,
ERA.0=1000,INFA.0=5000, RECA.0=50000,
SPA.0=0.4994506,SPJ.0=0.5882353) # this adds to the initial conditions given the state variables
sim <- simulate(sir,params=params,seed=3493885L,nsim=1,states=F,obs=F,as.data.frame=T) #
class(sir) # pomp object
class(sim) # data frame - even if I remove "as.data.frame" in the above code (sim)
## try with actual data:
lbvd<-read.csv("lbv_data_plustime.csv")
DSPJ<-lbvd$DRECJ/(lbvd$DRECJ+lbvd$DSUSJ)
DSPA<-lbvd$DRECA/(lbvd$DRECA+lbvd$DSUSA)
DPOPA<-lbvd$DRECA+lbvd$DSUSA
DPOPJ<-lbvd$DRECJ+lbvd$DSUSJ
DRECA<-lbvd$DRECA
DRECJ<-lbvd$DRECJ
times<-lbvd$cumulative_time
#
lbv.new<-cbind(times,DSPJ,DSPA,DRECJ,DRECA,DPOPJ,DPOPA)
pomp(
data = data.frame(
time=lbv.new[,1],  # time for simulations to run
#  DSPJ = lbv.new[,2],
#  DSPA = lbv.new[,3],
DRECJ = lbv.new[,4],
DRECA = lbv.new[,5],
DPOPJ = lbv.new[,6],
DPOPA = lbv.new[,7]
),
times='time',
t0=0,
## native routine for the process simulator:
rprocess=euler.sim(
step.fun="sir_euler_simulator",
delta.t=1,
#PACKAGE="pomp"  ## may be include if does not work - this is where to look for the c file
## name of the shared-object library containing the PACKAGE="pomp",
),
rmeasure="binomial_rmeasure",
dmeasure="binomial_dmeasure",
## the order of the state variables assumed in the native routines:
statenames=c("SUSJ","MDAJ", "SUSJM","EIJ","ERJ","INFJ", "RECJ", "SUSA", "EIA","ERA","INFA", "RECA","SPA","SPJ"),
obsnames=c(#"DSPJ","DSPA",
"DRECJ","DRECA","DPOPJ","DPOPA"),
## the order of the parameters assumed in the native routines:
paramnames=c("BETA","RHO",#"ETA",
"SUSJ.0","MDAJ.0", "SUSJM.0","EIJ.0","ERJ.0","INFJ.0", "RECJ.0", "SUSA.0", "EIA.0","ERA.0","INFA.0", "RECA.0","SPA.0","SPJ.0"),
initializer=function(params,t0,statenames,...){
x0<-params[paste(statenames,".0",sep="")]
names(x0)<-statenames
return(x0)
}
) -> lbvdat
plot(lbvdat)
#########
pf<-pfilter(lbvdat,params=c(params),Np=100,max.fail=100,tol=1e-20)
logLik(pf)
coef(pf)
logLik(pf)
coef(pf)
BetaV = seq(from=0.001,to=40,by=5)  # range of beta
RhoV = seq(from=0.001,to=1, by=0.125) # range of rho
BetaV
BetaV = seq(from=0.001,to=40,by=2.5)  # range of beta
RhoV
0.125/2
RhoV = seq(from=0.001,to=1, by=0.0625) # range of rho
BetaV = seq(from=0.001,to=40,by=2.5)  # range of beta
RhoV = seq(from=0.001,to=1, by=0.0625) # range of rho
RhoV
BetaV
#
parametset<- expand.grid(BetaV,RhoV)
dim(parametset)
nonV = matrix(c(
SUSJ.0=4000,MDAJ.0=4000, SUSJM.0=1000,EIJ.0=1000,ERJ.0=1000,INFJ.0=1000,
RECJ.0=10000,SUSA.0=50000, EIA.0=100,
ERA.0=1000,INFA.0=5000, RECA.0=50000,
SPA.0=0.4994506,SPJ.0=0.5882353),
ncol=14,
nrow=length(parametset[,1]),
byrow=T) #binded with non-varying parameters
dimnames(nonV)[[2]]=c("SUSJ.0","MDAJ.0","SUSJM.0","EIJ.0",
"ERJ.0","INFJ.0","RECJ.0","SUSA.0",
"EIA.0","ERA.0","INFA.0","RECA.0",
"SPA.0","SPJ.0") # naming non-varying columns
parsV<-cbind(parametset,nonV)
BETA = as.numeric(parsV[,1])
RHO = as.numeric(parsV[,2])
#ETA = as.numeric(parsV[,3])
SUSJ.0 = as.numeric(parsV[,3])
MDAJ.0 = as.numeric(parsV[,4])
SUSJM.0 = as.numeric(parsV[,5])
EIJ.0 = as.numeric(parsV[,6])
ERJ.0 = as.numeric(parsV[,7])
INFJ.0 = as.numeric(parsV[,8])
RECJ.0 = as.numeric(parsV[,9])
SUSA.0 = as.numeric(parsV[,10])
EIA.0 = as.numeric(parsV[,11])
ERA.0 = as.numeric(parsV[,12])
INFA.0 = as.numeric(parsV[,13])
RECA.0 = as.numeric(parsV[,14])
SPA.0 = as.numeric(parsV[,15])
SPJ.0 = as.numeric(parsV[,16])
params<-cbind(
BETA,
RHO,
#ETA,
SUSJ.0,
MDAJ.0,
SUSJM.0,
EIJ.0,
ERJ.0,
INFJ.0,
RECJ.0,
SUSA.0,
EIA.0,
ERA.0,
INFA.0,
RECA.0,
SPA.0,
SPJ.0
)
results<-array(NA,dim=c(length(parametset[,1]),3))
## nb check # particles - reduced for training
for (j in 1:length(params[,1])){
results[j,1]<-logLik(pfilter(lbvdat,params=c(params[j,]),Np=100,max.fail=100,tol=1e-20))
#pf<-pfilter(lbvdat,params=c(params[j,]),Np=6000,max.fail=1000,tol=1e-20)
results[j,2:3]<-#c(logLik(pf))}
#
c(params[j,1],params[j,2])
}
library(akima)
library(lattice)
library(tgp)
library(rgl)
library(fields)
rholab<-expression(symbol(rho))
betalab<-expression(symbol(beta))
zzg <- interp(x=results[,2], #
y=results[,3], #
z=results[,1],
duplicate=T)#,grid.len=c(50,50))#,span=0.1)
image(zzg,ann=T,xlim=c(0,30),ylim=c(0,0.5), ylab=rholab,xlab=betalab)
contour(zzg,add=T,labcex=1,drawlabels=T,nlevels=10)
#contour(zzg,add=F,labcex=1,drawlabels=T,nlevels=100)
par(omi=c(1,1,0.5,1))
par(mai=c(0.8,0.8,0.8,0.8))
surface(zzg,#col ="#FFFFFF",
ylab=rholab,xlab=betalab,
#zlim=c(0,10),
labcex=1)
contour(zzg,add=T,labcex=1,drawlabels=F,nlevels=50)
#plot(results[,1])
max(results[,1])
results[results[,1]==max(results[,1]),]
minLL<-as.data.frame(t(results[results[,1]==min(results[,1]),]))
names(minLL)<-c("negll","Beta","Rho")
points(x=minLL$Beta,y=minLL$Rho,pch=16,col="pink")
max(results[,1])
results[results[,1]==max(results[,1]),]
#plot(results[,1])
max(results[,1])
results[results[,1]==max(results[,1]),]
maxLL<-as.data.frame(t(results[results[,1]==max(results[,1]),]))
names(maxLL)<-c("negll","Beta","Rho")
points(x=maxLL$Beta,y=maxLL$Rho,pch=16,col="pink")
surface(zzg,#col ="#FFFFFF",
ylab=rholab,xlab=betalab,
#zlim=c(0,10),
labcex=1)
points(x=zzg[[1]][33],y=zzg[[2]][14],pch=16,col="yellow")
points(x=maxLL$Beta,y=maxLL$Rho,pch=16,col="pink")
surface(zzg,#col ="#FFFFFF",
ylab=rholab,xlab=betalab,
#zlim=c(0,10),
labcex=1)
contour(zzg,add=T,labcex=1,drawlabels=F,nlevels=50)
rholab<-expression(symbol(rho))
betalab<-expression(symbol(beta))
zzg <- interp(x=results[,2], #
z=results[,1],
y=results[,3], #
image(zzg,ann=T,xlim=c(0,30),ylim=c(0,0.5), ylab=rholab,xlab=betalab)
duplicate=T)#,grid.len=c(50,50))#,span=0.1)
contour(zzg,add=T,labcex=1,drawlabels=T,nlevels=10)
#contour(zzg,add=F,labcex=1,drawlabels=T,nlevels=100)
par(omi=c(1,1,0.5,1))
par(mai=c(0.8,0.8,0.8,0.8))
surface(zzg,#col ="#FFFFFF",
ylab=rholab,xlab=betalab,
#zlim=c(0,10),
labcex=1)
contour(zzg,add=T,labcex=1,drawlabels=F,nlevels=50)
#plot(results[,1])
max(results[,1])
results[results[,1]==max(results[,1]),]
maxLL<-as.data.frame(t(results[results[,1]==max(results[,1]),]))
names(maxLL)<-c("negll","Beta","Rho")
points(x=maxLL$Beta,y=maxLL$Rho,pch=16,col="pink")
points(x=zzg[[1]][33],y=zzg[[2]][14],pch=16,col="yellow")
which(zzg[[3]] == min(zzg[[3]]))
which(zzg[[3]] == max(zzg[[3]]))
resdf<-as.data.frame(results)#,value=cut(results[,1],breaks=seq(min(results[,1]),max(results[,1]),25)))
names(resdf)<-c("nll","beta","rho")#,"NegLL")
library(ggplot2)
p <- ggplot(resdf) +
geom_tile(aes(beta,rho,fill=nll)) +
geom_contour(aes(x=beta,y=rho,z=nll), colour="white",bins=25)
p
p = p + geom_point(aes(y=0.33, x=32.4),colour="red")
p
write.csv(resdf,file="pfilterres.csv")
test<-read.csv("pfilterres.csv",header=T)
test
0.0625/2
RhoV = seq(from=0.001,to=0.5, by=0.03125) # range of rho
RhoV
RhoV = seq(from=0.001,to=0.5, by=0.03125) # range of rho
zzg <- interp(x=results[,2], #
y=results[,3], #
z=results[,1],
duplicate=T)#,grid.len=c(50,50))#,span=0.1)
image(zzg,ann=T,xlim=c(0,30),ylim=c(0,0.5), ylab=rholab,xlab=betalab)
image(zzg,ann=T,xlim=c(0,20),ylim=c(0,0.5), ylab=rholab,xlab=betalab)
contour(zzg,add=T,labcex=1,drawlabels=T,nlevels=10)
points(x=maxLL$Beta,y=maxLL$Rho,pch=16,col="pink")
contour(zzg,add=T,labcex=1,drawlabels=F,nlevels=50)
surface(zzg,#col ="#FFFFFF",
ylab=rholab,xlab=betalab,
#zlim=c(0,10),
labcex=1)
contour(zzg,add=T,labcex=1,drawlabels=F,nlevels=10)
surface(zzg,#col ="#FFFFFF",
ylab=rholab,xlab=betalab,
#zlim=c(0,10),
labcex=1)
points(x=maxLL$Beta,y=maxLL$Rho,pch=16,col="pink")
maxLL
results
pfilter
pf
pf$coef
coef(pf)
se(pf)
error(pf)
points(x=maxLL$Beta,y=maxLL$Rho,pch=16,col="white")
maxLL
# dyn.unload("lbvseirNoSeasFreqTwoParsMeasureBinom.dll")
pomp(
data = data.frame(
time=seq(from=0,to=365*25,by=1),  # time for simulations to run
X = NA # dummy variables
),
times="time",
t0=0,
## native routine for the process simulator:
rprocess=euler.sim(
step.fun="sir_euler_simulator",
delta.t=1,
#PACKAGE="pomp"  ## may be include if does not work - this is where to look for the c file
## name of the shared-object library containing the PACKAGE="pomp",
),
## the order of the state variables assumed in the native routines:
statenames=c("SUSJ","MDAJ", "SUSJM","EIJ","ERJ","INFJ", "RECJ", "SUSA", "EIA","ERA","INFA", "RECA","SPA","SPJ"),
## the order of the parameters assumed in the native routines:
paramnames=c("BETA",
"RHO",
# "ETA",
"SUSJ.0","MDAJ.0", "SUSJM.0","EIJ.0","ERJ.0","INFJ.0", "RECJ.0", "SUSA.0", "EIA.0","ERA.0","INFA.0", "RECA.0","SPA.0","SPJ.0"),
initializer=function(params,t0,statenames,...){
x0<-params[paste(statenames,".0",sep="")]
names(x0)<-statenames
return(x0)
}
) -> sir
params <- c(
BETA=7.5,
RHO=0.0635,
#  ETA=0.1,
SUSJ.0=4000,MDAJ.0=4000, SUSJM.0=1000,EIJ.0=1000,ERJ.0=1000,INFJ.0=1000,
RECJ.0=10000,SUSA.0=50000, EIA.0=100,
ERA.0=1000,INFA.0=5000, RECA.0=50000,
SPA.0=0.4994506,SPJ.0=0.5882353)
#
sim <- simulate(sir,params=c(params),seed=3493885L,nsim=1,states=T,obs=F,as.data.frame=T) #
class(sir) # pomp object
class(sim) # data frame - change states, obs and data.frame if want pomp obj
#
plot(sim$time,sim$SUSJ,type="l")
points(sim$time,sim$RECJ,col="green",type="l")
points(sim$time,sim$MDA,col="brown",type="l")
points(sim$time,sim$INFJ,col="red",type="l")
#
plot(sim$time,sim$RECA,col="green",type="l",ylim=c(0,max(sim$RECA)))
points(sim$time,sim$SUSA,type="l")
points(sim$time,sim$INFA,col="red",type="l")
#
plot(sim$time,sim$SPA,type="l",col="green",ylim=c(0,1))
points(sim$time,sim$SPJ,type="l",col="red")
#########################################################
plot(sim$time,sim$SPA,type="l",col="darkgreen",ylim=c(0,1))
points(sim$time,sim$SPJ,type="l",col="darkblue")
poinst(sim$time,sim$INFA,type="l",col="orange",ylim=c(0,1))
points(sim$time,sim$INFA,type="l",col="orange",ylim=c(0,1))
points(sim$time,sim$INFJ,type="l",col="red")
plot(sim$time,sim$INFA,type="l",col="orange",ylim=c(0,1))
plot(sim$time,sim$INFA,type="l",col="orange")#,ylim=c(0,1))
points(sim$time,sim$INFJ,type="l",col="red")
